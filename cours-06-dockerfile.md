# Cours 6 : Cr√©er vos Propres Images avec Dockerfile üèóÔ∏è

## üéØ Ce que vous allez apprendre

√Ä la fin de ce cours, vous saurez :
- C'est quoi un Dockerfile
- √âcrire votre premier Dockerfile
- Les 10 instructions essentielles (FROM, RUN, COPY, CMD...)
- Construire une image √† partir d'un Dockerfile
- Cr√©er une vraie application Node.js dans Docker
- Les bonnes pratiques pour des images efficaces

**Dur√©e : 45 minutes (lecture + pratique)**

---

## üìñ Partie 1 : C'est quoi un Dockerfile ?

### Le probl√®me jusqu'√† maintenant

Jusqu'ici, vous avez utilis√© des images **d√©j√† faites** :
- ubuntu
- nginx
- mysql
- wordpress

**Mais comment cr√©er VOTRE propre image ?**

Par exemple :
- Votre application Node.js
- Votre site Python Django
- Votre API en Go
- N'importe quoi !

### La solution : Le Dockerfile

**Un Dockerfile = Une recette pour cr√©er une image**

**Analogie :**
- **Sans Dockerfile** : Acheter un g√¢teau tout fait au supermarch√©
- **Avec Dockerfile** : √âcrire la recette et faire votre propre g√¢teau

**Avantages :**
- ‚úÖ Personnalisation totale
- ‚úÖ Reproductible (m√™me r√©sultat √† chaque fois)
- ‚úÖ Automatique (pas besoin de tout refaire manuellement)
- ‚úÖ Partageable (donnez la recette √† vos coll√®gues)

### C'est quoi concr√®tement ?

**Un Dockerfile = un simple fichier texte qui contient des instructions**

**Exemple super simple :**
```dockerfile
FROM ubuntu
RUN apt-get update
RUN apt-get install -y nginx
CMD ["nginx", "-g", "daemon off;"]
```

**Traduction en fran√ßais :**
1. Prends l'image Ubuntu comme base
2. Mets √† jour les paquets
3. Installe nginx
4. D√©marre nginx quand le conteneur se lance

**4 lignes = une image nginx personnalis√©e !** üéâ

### Le processus complet

```
1. Vous √©crivez un Dockerfile
         ‚¨áÔ∏è
2. Vous "construisez" l'image avec docker build
         ‚¨áÔ∏è
3. Docker cr√©e l'image automatiquement
         ‚¨áÔ∏è
4. Vous pouvez cr√©er des conteneurs avec cette image
```

---

## üìù Partie 2 : Votre Premier Dockerfile

### Projet simple : Une page web HTML

**Mission : Cr√©er une image qui sert une page HTML personnalis√©e**

**√âtape 1 : Cr√©er un dossier pour le projet**
```bash
mkdir ~/mon-premier-dockerfile
cd ~/mon-premier-dockerfile
```

**√âtape 2 : Cr√©er la page HTML**
```bash
cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Ma Premi√®re Image Docker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 50px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        h1 { font-size: 48px; }
        p { font-size: 24px; }
    </style>
</head>
<body>
    <h1>üéâ Bravo !</h1>
    <p>Vous avez cr√©√© votre premi√®re image Docker !</p>
    <p>Cette page vient de VOTRE image personnalis√©e</p>
</body>
</html>
EOF
```

**√âtape 3 : Cr√©er le Dockerfile**

‚ö†Ô∏è **IMPORTANT : Le fichier DOIT s'appeler exactement `Dockerfile` (avec un D majuscule, pas d'extension)**

```bash
cat > Dockerfile << 'EOF'
# Partir de l'image nginx officielle
FROM nginx:alpine

# Copier notre page HTML dans le conteneur
COPY index.html /usr/share/nginx/html/index.html

# Nginx d√©marre automatiquement avec cette image
EOF
```

**Explication ligne par ligne :**

1. `FROM nginx:alpine` 
   - On part de l'image nginx (version alpine = l√©g√®re)
   - C'est l'image de BASE

2. `COPY index.html /usr/share/nginx/html/index.html`
   - On copie notre fichier `index.html` (sur notre PC)
   - Vers le chemin `/usr/share/nginx/html/index.html` (dans l'image)

3. Le `# Nginx d√©marre...` est un commentaire (explications)

**√âtape 4 : V√©rifier que vous avez bien 2 fichiers**
```bash
ls
```

Vous devez voir :
```
Dockerfile
index.html
```

‚úÖ **Si vous avez ces 2 fichiers, continuez !**

**√âtape 5 : Construire l'image**

**Commande magique :**
```bash
docker build -t mon-site-web .
```

**Explication :**
- `docker build` : Commande pour construire une image
- `-t mon-site-web` : Donne le nom "mon-site-web" √† l'image
- `.` : Le point = cherche le Dockerfile dans le dossier actuel

**Ce que vous verrez :**
```
[+] Building 2.5s (7/7) FINISHED
 => [internal] load build definition from Dockerfile
 => [internal] load .dockerignore
 => [internal] load metadata for docker.io/library/nginx:alpine
 => [1/2] FROM docker.io/library/nginx:alpine
 => [internal] load build context
 => [2/2] COPY index.html /usr/share/nginx/html/index.html
 => exporting to image
 => => naming to docker.io/library/mon-site-web
```

üéâ **Votre image est cr√©√©e !**

**√âtape 6 : V√©rifier que l'image existe**
```bash
docker images
```

Vous devez voir `mon-site-web` dans la liste ! ‚úÖ

**√âtape 7 : Lancer un conteneur avec VOTRE image**
```bash
docker run -d -p 8080:80 --name mon-super-site mon-site-web
```

**√âtape 8 : Tester dans le navigateur**

Ouvrez : `http://localhost:8080`

üéä **Vous voyez votre page personnalis√©e !**

**BRAVO ! Vous venez de cr√©er votre premi√®re image Docker !** üéâ

---

## üîß Partie 3 : Les Instructions Essentielles du Dockerfile

### Instruction 1 : FROM (obligatoire)

**D√©finir l'image de base**

**Syntaxe :**
```dockerfile
FROM image:tag
```

**Exemples :**
```dockerfile
FROM ubuntu:22.04        # Ubuntu version 22.04
FROM node:18             # Node.js version 18
FROM python:3.11         # Python 3.11
FROM nginx:alpine        # Nginx version alpine (l√©g√®re)
FROM scratch             # Image vide (rare)
```

‚ö†Ô∏è **FROM doit TOUJOURS √™tre la premi√®re instruction !**

---

### Instruction 2 : COPY

**Copier des fichiers de votre PC vers l'image**

**Syntaxe :**
```dockerfile
COPY source destination
```

**Exemples :**
```dockerfile
# Copier un fichier
COPY app.js /app/app.js

# Copier un dossier complet
COPY ./src /app/src

# Copier plusieurs fichiers
COPY package.json package-lock.json /app/

# Copier tout le dossier actuel
COPY . /app
```

**Diff√©rence avec ADD :**
- `COPY` : Simple copie de fichiers (recommand√©)
- `ADD` : Comme COPY mais peut t√©l√©charger des URLs et extraire des archives (√©vitez-le)

**R√®gle : Utilisez toujours COPY, pas ADD**

---

### Instruction 3 : RUN

**Ex√©cuter des commandes pendant la CONSTRUCTION de l'image**

**Syntaxe :**
```dockerfile
RUN commande
```

**Exemples :**
```dockerfile
# Installer des paquets sur Ubuntu
RUN apt-get update && apt-get install -y curl

# Installer des d√©pendances Node.js
RUN npm install

# Installer des d√©pendances Python
RUN pip install -r requirements.txt

# Cr√©er un dossier
RUN mkdir -p /app/data

# Plusieurs commandes en une ligne
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean
```

**Important :** 
- `RUN` s'ex√©cute PENDANT la construction
- Pas quand le conteneur d√©marre !

---

### Instruction 4 : CMD

**Commande √† ex√©cuter quand le conteneur D√âMARRE**

**Syntaxe (recommand√©e) :**
```dockerfile
CMD ["executable", "param1", "param2"]
```

**Exemples :**
```dockerfile
# D√©marrer nginx
CMD ["nginx", "-g", "daemon off;"]

# D√©marrer une app Node.js
CMD ["node", "app.js"]

# D√©marrer Python
CMD ["python", "app.py"]

# D√©marrer un script bash
CMD ["./start.sh"]
```

**Important :**
- Il ne peut y avoir qu'UN SEUL `CMD` dans un Dockerfile
- S'il y en a plusieurs, seul le dernier compte
- `CMD` peut √™tre √©cras√© quand vous faites `docker run`

---

### Instruction 5 : WORKDIR

**D√©finir le dossier de travail dans le conteneur**

**Syntaxe :**
```dockerfile
WORKDIR /chemin
```

**Exemples :**
```dockerfile
WORKDIR /app

# Maintenant toutes les commandes se passent dans /app
COPY . .              # Copie dans /app
RUN npm install       # Ex√©cute dans /app
CMD ["node", "app.js"] # D√©marre depuis /app
```

**Pourquoi c'est important ?**
- Sans `WORKDIR`, vous √™tes √† la racine `/`
- Avec `WORKDIR`, vous d√©finissez o√π vous travaillez
- Plus propre et organis√©

---

### Instruction 6 : ENV

**D√©finir des variables d'environnement**

**Syntaxe :**
```dockerfile
ENV NOM_VARIABLE=valeur
```

**Exemples :**
```dockerfile
# D√©finir le port
ENV PORT=3000

# D√©finir l'environnement
ENV NODE_ENV=production

# Plusieurs variables
ENV DATABASE_HOST=localhost \
    DATABASE_PORT=5432 \
    DATABASE_NAME=myapp
```

**Utilisation dans le code :**
```javascript
// Dans votre app Node.js
const port = process.env.PORT || 3000;
```

---

### Instruction 7 : EXPOSE

**Indiquer quel port l'application utilise**

**Syntaxe :**
```dockerfile
EXPOSE port
```

**Exemples :**
```dockerfile
EXPOSE 80        # HTTP
EXPOSE 443       # HTTPS
EXPOSE 3000      # Node.js app
EXPOSE 5432      # PostgreSQL
```

‚ö†Ô∏è **Important :** `EXPOSE` est juste une **documentation** !
- √áa n'ouvre pas vraiment le port
- Vous devez quand m√™me utiliser `-p` avec `docker run`
- C'est pour indiquer aux autres d√©veloppeurs quel port utiliser

---

### Instruction 8 : USER

**D√©finir l'utilisateur qui ex√©cute les commandes**

**Syntaxe :**
```dockerfile
USER nom_utilisateur
```

**Exemple :**
```dockerfile
# Cr√©er un utilisateur non-root
RUN useradd -m -s /bin/bash appuser

# Passer √† cet utilisateur
USER appuser

# Maintenant toutes les commandes s'ex√©cutent en tant que appuser
CMD ["node", "app.js"]
```

**Pourquoi ?**
- S√©curit√© : Ne jamais ex√©cuter en tant que root dans un conteneur
- Bonne pratique en production

---

### Instruction 9 : VOLUME

**D√©finir un point de montage pour un volume**

**Syntaxe :**
```dockerfile
VOLUME /chemin
```

**Exemple :**
```dockerfile
VOLUME /app/data
```

**Note :** On utilise rarement `VOLUME` dans un Dockerfile. Il vaut mieux d√©finir les volumes avec `docker run -v`.

---

### Instruction 10 : ENTRYPOINT

**D√©finir la commande principale (non modifiable)**

**Diff√©rence avec CMD :**
- `CMD` : Peut √™tre √©cras√©e avec `docker run`
- `ENTRYPOINT` : Commande fixe, on peut seulement ajouter des arguments

**Exemple :**
```dockerfile
ENTRYPOINT ["python", "app.py"]

# Maintenant on peut faire :
# docker run mon-image --debug
# √áa ex√©cutera : python app.py --debug
```

**On utilise rarement ENTRYPOINT au d√©but. Concentrez-vous sur CMD.**

---

## üíª Partie 4 : Projet Complet - API Node.js

### Mission : Cr√©er une API REST avec Docker

**On va cr√©er :**
1. Une API Node.js simple
2. Un Dockerfile pour l'empaqueter
3. Construire l'image
4. Lancer et tester

### √âtape par √©tape

**√âtape 1 : Cr√©er le dossier du projet**
```bash
mkdir ~/api-nodejs-docker
cd ~/api-nodejs-docker
```

---

**√âtape 2 : Cr√©er package.json**
```bash
cat > package.json << 'EOF'
{
  "name": "api-docker",
  "version": "1.0.0",
  "description": "API simple avec Docker",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  }
}
EOF
```

---

**√âtape 3 : Cr√©er l'application app.js**
```bash
cat > app.js << 'EOF'
const express = require('express');
const app = express();
const PORT = process.env.PORT || 3000;

// Route principale
app.get('/', (req, res) => {
  res.json({
    message: "Bienvenue sur mon API Docker !",
    version: "1.0.0",
    status: "running"
  });
});

// Route /health pour v√©rifier que l'API fonctionne
app.get('/health', (req, res) => {
  res.json({ status: "OK", timestamp: new Date() });
});

// Route /users (exemple)
app.get('/users', (req, res) => {
  res.json([
    { id: 1, name: "Alice", role: "Admin" },
    { id: 2, name: "Bob", role: "User" },
    { id: 3, name: "Charlie", role: "User" }
  ]);
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ API d√©marr√©e sur le port ${PORT}`);
  console.log(`üì° http://localhost:${PORT}`);
});
EOF
```

---

**√âtape 4 : Cr√©er le Dockerfile**
```bash
cat > Dockerfile << 'EOF'
# √âtape 1 : Partir d'une image Node.js
FROM node:18-alpine

# √âtape 2 : D√©finir le dossier de travail
WORKDIR /app

# √âtape 3 : Copier les fichiers package
COPY package*.json ./

# √âtape 4 : Installer les d√©pendances
RUN npm install

# √âtape 5 : Copier le code source
COPY . .

# √âtape 6 : Exposer le port (documentation)
EXPOSE 3000

# √âtape 7 : D√©finir la commande de d√©marrage
CMD ["npm", "start"]
EOF
```

**Explication d√©taill√©e :**

1. `FROM node:18-alpine`
   - Image de base : Node.js version 18
   - Alpine = version ultra-l√©g√®re de Linux (5 Mo au lieu de 50 Mo !)

2. `WORKDIR /app`
   - On travaille dans le dossier `/app`
   - Tout ce qui suit se passe l√†

3. `COPY package*.json ./`
   - On copie `package.json` et `package-lock.json`
   - Pourquoi en premier ? Pour optimiser le cache (on verra √ßa plus tard)

4. `RUN npm install`
   - Installe toutes les d√©pendances (express, etc.)

5. `COPY . .`
   - Copie tout le reste du code

6. `EXPOSE 3000`
   - Documentation : l'API √©coute sur le port 3000

7. `CMD ["npm", "start"]`
   - D√©marre l'API avec `npm start`

---

**√âtape 5 : V√©rifier les fichiers**
```bash
ls
```

Vous devez avoir :
```
Dockerfile
package.json
app.js
```

‚úÖ **Si c'est bon, continuez !**

---

**√âtape 6 : Construire l'image**
```bash
docker build -t mon-api .
```

**Ce que vous verrez :**
```
[+] Building 15.3s (10/10) FINISHED
 => [1/5] FROM docker.io/library/node:18-alpine
 => [2/5] WORKDIR /app
 => [3/5] COPY package*.json ./
 => [4/5] RUN npm install
 => [5/5] COPY . .
 => exporting to image
Successfully built abc123def456
Successfully tagged mon-api:latest
```

‚è±Ô∏è **√áa prend 15-30 secondes la premi√®re fois** (t√©l√©chargement de Node.js + installation d'express)

---

**√âtape 7 : V√©rifier l'image**
```bash
docker images mon-api
```

Vous voyez `mon-api` avec une taille d'environ 180 Mo.

---

**√âtape 8 : Lancer le conteneur**
```bash
docker run -d -p 3000:3000 --name api-container mon-api
```

---

**√âtape 9 : V√©rifier les logs**
```bash
docker logs api-container
```

Vous devez voir :
```
üöÄ API d√©marr√©e sur le port 3000
üì° http://localhost:3000
```

‚úÖ **L'API fonctionne !**

---

**√âtape 10 : Tester l'API**

**Dans le navigateur :**
```
http://localhost:3000
```

Vous voyez :
```json
{
  "message": "Bienvenue sur mon API Docker !",
  "version": "1.0.0",
  "status": "running"
}
```

**Tester les autres routes :**
```
http://localhost:3000/health
http://localhost:3000/users
```

üéâ **Tout fonctionne !**

---

**√âtape 11 : Tester avec curl (dans le terminal)**
```bash
curl http://localhost:3000
curl http://localhost:3000/health
curl http://localhost:3000/users
```

---

**√âtape 12 : Modifier le code et reconstruire**

Modifiez `app.js` pour ajouter une nouvelle route :
```bash
cat >> app.js << 'EOF'

// Nouvelle route
app.get('/info', (req, res) => {
  res.json({
    hostname: require('os').hostname(),
    platform: process.platform,
    nodeVersion: process.version,
    uptime: process.uptime()
  });
});
EOF
```

**Reconstruire l'image :**
```bash
docker build -t mon-api .
```

**Arr√™ter l'ancien conteneur et lancer le nouveau :**
```bash
docker stop api-container
docker rm api-container
docker run -d -p 3000:3000 --name api-container mon-api
```

**Tester la nouvelle route :**
```
http://localhost:3000/info
```

‚úÖ **Vous voyez les nouvelles infos !**

---

## üìä Partie 5 : Les Bonnes Pratiques

### ‚úÖ Bonne pratique 1 : Utiliser des images Alpine

**Pourquoi ?**
- Plus petites (5-50 Mo au lieu de 100-500 Mo)
- Plus rapides √† t√©l√©charger
- Plus s√©curis√©es (moins de code = moins de failles)

**Exemples :**
```dockerfile
FROM node:18-alpine      # Au lieu de node:18
FROM python:3.11-alpine  # Au lieu de python:3.11
FROM nginx:alpine        # Au lieu de nginx
```

---

### ‚úÖ Bonne pratique 2 : Ordre des instructions

**Mauvais ordre (lent) ‚ùå :**
```dockerfile
FROM node:18-alpine
COPY . .                    # Copie TOUT
RUN npm install            # Si vous changez le code, √ßa r√©installe TOUT
CMD ["npm", "start"]
```

**Bon ordre (rapide) ‚úÖ :**
```dockerfile
FROM node:18-alpine
COPY package*.json ./      # Copie juste les d√©pendances
RUN npm install            # Cache cette √©tape si package.json ne change pas
COPY . .                   # Copie le code (change souvent)
CMD ["npm", "start"]
```

**Pourquoi ?**
Docker utilise un **cache**. Si une instruction ne change pas, il r√©utilise le cache au lieu de tout refaire.

---

### ‚úÖ Bonne pratique 3 : Un seul RUN pour plusieurs commandes

**Mauvais (cr√©e plusieurs couches) ‚ùå :**
```dockerfile
RUN apt-get update
RUN apt-get install -y curl
RUN apt-get install -y git
RUN apt-get clean
```

**Bon (une seule couche) ‚úÖ :**
```dockerfile
RUN apt-get update && \
    apt-get install -y curl git && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

**Avantage :** Image plus petite et plus rapide √† construire.

---

### ‚úÖ Bonne pratique 4 : Utiliser .dockerignore

**C'est quoi ?**
Comme `.gitignore`, mais pour Docker. √áa √©vite de copier des fichiers inutiles dans l'image.

**Cr√©er un .dockerignore :**
```bash
cat > .dockerignore << 'EOF'
node_modules
npm-debug.log
.git
.gitignore
README.md
.env
.DS_Store
Dockerfile
.dockerignore
EOF
```

**Pourquoi ?**
- `node_modules` : On va les r√©installer avec `npm install`, pas besoin de les copier
- `.git` : Inutile dans l'image
- `.env` : Fichiers secrets ne doivent jamais √™tre dans l'image

---

### ‚úÖ Bonne pratique 5 : Ne pas ex√©cuter en root

**Mauvais (root = dangereux) ‚ùå :**
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .
CMD ["node", "app.js"]
# Par d√©faut, √ßa s'ex√©cute en root !
```

**Bon (utilisateur d√©di√©) ‚úÖ :**
```dockerfile
FROM node:18-alpine

# Cr√©er un utilisateur
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

WORKDIR /app

# Copier et installer en root
COPY package*.json ./
RUN npm install

# Copier le code
COPY . .

# Changer les permissions
RUN chown -R nodejs:nodejs /app

# Passer √† l'utilisateur non-root
USER nodejs

CMD ["node", "app.js"]
```

---

### ‚úÖ Bonne pratique 6 : Versions sp√©cifiques

**Mauvais (version change) ‚ùå :**
```dockerfile
FROM node:latest     # Quelle version ? On ne sait pas !
```

**Bon (version fix√©e) ‚úÖ :**
```dockerfile
FROM node:18-alpine  # Toujours la version 18
```

**Pourquoi ?**
- `latest` peut changer et casser votre application
- Versions sp√©cifiques = reproductible

---

### ‚úÖ Bonne pratique 7 : Labels pour la documentation

```dockerfile
LABEL maintainer="votre@email.com"
LABEL version="1.0.0"
LABEL description="API REST avec Node.js"
```

---

## üìù Partie 6 : Exercice Complet

### Exercice : Cr√©er une application Python Flask

**Mission : Cr√©er une API Python avec Docker**

**√âtape 1 : Cr√©er le dossier**
```bash
mkdir ~/api-python-docker
cd ~/api-python-docker
```

**√âtape 2 : Cr√©er requirements.txt**
```bash
cat > requirements.txt << 'EOF'
Flask==2.3.0
EOF
```

**√âtape 3 : Cr√©er app.py**
```bash
cat > app.py << 'EOF'
from flask import Flask, jsonify
import os

app = Flask(__name__)

@app.route('/')
def home():
    return jsonify({
        "message": "API Python avec Docker",
        "status": "running"
    })

@app.route('/hello/<name>')
def hello(name):
    return jsonify({
        "message": f"Bonjour {name} !",
        "from": "Docker"
    })

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port)
EOF
```

**√âtape 4 : Cr√©er le Dockerfile**
```bash
cat > Dockerfile << 'EOF'
# Image de base
FROM python:3.11-alpine

# Dossier de travail
WORKDIR /app

# Copier les d√©pendances
COPY requirements.txt .

# Installer les d√©pendances
RUN pip install --no-cache-dir -r requirements.txt

# Copier le code
COPY . .

# Exposer le port
EXPOSE 5000

# Commande de d√©marrage
CMD ["python", "app.py"]
EOF
```

**√âtape 5 : Construire**
```bash
docker build -t api-python .
```

**√âtape 6 : Lancer**
```bash
docker run -d -p 5000:5000 --name python-api api-python
```

**√âtape 7 : Tester**
```
http://localhost:5000
http://localhost:5000/hello/Alice
```

‚úÖ **Si √ßa marche, BRAVO !**

**Nettoyage :**
```bash
docker stop python-api
docker rm python-api
```

---

## ‚úÖ Quiz de validation

**Question 1 : Quelle instruction DOIT √™tre en premier dans un Dockerfile ?**

- A) RUN
- B) COPY
- C) FROM
- D) CMD

<details>
<summary>Voir la r√©ponse</summary>

‚úÖ **R√©ponse C : FROM**

`FROM` d√©finit l'image de base et doit TOUJOURS √™tre la premi√®re instruction.

</details>

---

**Question 2 : Quelle diff√©rence entre RUN et CMD ?**

- A) Aucune diff√©rence
- B) RUN s'ex√©cute pendant la construction, CMD au d√©marrage du conteneur
- C) CMD s'ex√©cute pendant la construction, RUN au d√©marrage
- D) RUN est plus rapide

<details>
<summary>Voir la r√©ponse</summary>

‚úÖ **R√©ponse B**

- `RUN` : Ex√©cut√© PENDANT la construction de l'image (installer des paquets, etc.)
- `CMD` : Ex√©cut√© quand le conteneur D√âMARRE

</details>

---

**Question 3 : Commande pour construire une image nomm√©e "mon-app" ?**

- A) `docker create -t mon-app .`
- B) `docker build -t mon-app .`
- C) `docker make mon-app`
- D) `docker image mon-app .`

<details>
<summary>Voir la r√©ponse</summary>

‚úÖ **R√©ponse B : `docker build -t mon-app .`**

- `docker build` : Construire une image
- `-t mon-app` : Tag (nom) de l'image
- `.` : Chercher le Dockerfile dans le dossier actuel

</details>

---

**Question 4 : √Ä quoi sert WORKDIR ?**

- A) Cr√©er un nouveau dossier
- B) D√©finir o√π on travaille dans le conteneur
- C) Copier des fichiers
- D) Installer des programmes

<details>
<summary>Voir la r√©ponse</summary>

‚úÖ **R√©ponse B : D√©finir o√π on travaille dans le conteneur**

`WORKDIR /app` fait que toutes les commandes suivantes s'ex√©cutent dans `/app`.

</details>

---

**Question 5 : Pourquoi utiliser des images Alpine ?**

- A) Elles sont plus belles
- B) Elles sont plus petites et rapides
- C) Elles sont obligatoires
- D) Elles contiennent plus de logiciels

<details>
<summary>Voir la r√©ponse</summary>

‚úÖ **R√©ponse B : Elles sont plus petites et rapides**

Alpine = version ultra-l√©g√®re de Linux. node:18-alpine fait ~50 Mo au lieu de ~300 Mo !

</details>

---

## üéØ R√©capitulatif (√Ä RETENIR)

### Le Dockerfile en 3 √©tapes

**1. Image de base**
```dockerfile
FROM node:18-alpine
```

**2. Pr√©parer l'environnement**
```dockerfile
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
```

**3. D√©finir le d√©marrage**
```dockerfile
EXPOSE 3000
CMD ["npm", "start"]
```

### Les instructions essentielles

| Instruction | Usage | Exemple |
|------------|-------|---------|
| `FROM` | Image de base | `FROM node:18-alpine` |
| `WORKDIR` | Dossier de travail | `WORKDIR /app` |
| `COPY` | Copier des fichiers | `COPY . .` |
| `RUN` | Ex√©cuter pendant construction | `RUN npm install` |
| `CMD` | Commande au d√©marrage | `CMD ["node", "app.js"]` |
| `EXPOSE` | Documenter le port | `EXPOSE 3000` |
| `ENV` | Variables d'environnement | `ENV PORT=3000` |

### Construire et lancer

```bash
# Construire
docker build -t nom-image .

# Lancer
docker run -d -p 3000:3000 nom-image
```

---

## üöÄ Et maintenant ?

**√âNORME BRAVO ! Vous savez cr√©er vos propres images Docker !** üéâ

### Ce que vous ma√Ætrisez maintenant :

- ‚úÖ √âcrire un Dockerfile
- ‚úÖ Les 10 instructions essentielles
- ‚úÖ Construire des images
- ‚úÖ Cr√©er des API Node.js et Python dans Docker
- ‚úÖ Les bonnes pratiques pour des images optimis√©es

### Dans le prochain cours (Cours 7) :

**Optimiser et s√©curiser vos images** üîí

Vous apprendrez :
1. R√©duire la taille des images (multi-stage builds)
2. Acc√©l√©rer les builds avec le cache
3. S√©curiser vos images
4. Scanner les vuln√©rabilit√©s
5. Publier sur Docker Hub

---

## üìö Template de Dockerfile (√† r√©utiliser)

**Pour Node.js :**
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

**Pour Python :**
```dockerfile
FROM python:3.11-alpine
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]
```

**Pour un site statique :**
```dockerfile
FROM nginx:alpine
COPY . /usr/share/nginx/html
```

---

**üéì Vous √™tes pr√™t pour le Cours 7 (Optimisation) !**

Excellent travail ! Vous venez de franchir l'√©tape la plus importante de Docker : cr√©er vos propres images ! La suite va vous montrer comment les rendre encore meilleures. üí™üöÄ
