# Cours 11 : Debug et Troubleshooting Docker üîß

## üéØ Objectifs du cours

√Ä la fin de ce cours, vous saurez :
- Diagnostiquer et r√©soudre les probl√®mes Docker courants
- Utiliser les commandes de diagnostic avanc√©es
- Optimiser les performances de vos conteneurs
- D√©bugger vos applications dans Docker
- √âviter les pi√®ges classiques

**Dur√©e estim√©e : 40 minutes**

---

## üìñ Introduction : Pourquoi ce cours est important

Docker peut parfois sembler myst√©rieux quand quelque chose ne fonctionne pas. Ce cours vous donne TOUS les outils pour comprendre et r√©soudre n'importe quel probl√®me ! üí™

---

## üö® Probl√®me 1 : "Mon conteneur d√©marre puis s'arr√™te imm√©diatement"

### Sympt√¥me

```bash
docker run -d mon-image
# Le conteneur appara√Æt puis dispara√Æt instantan√©ment
docker ps
# Rien ne s'affiche !
```

### Diagnostic

```bash
# 1. Voir TOUS les conteneurs (m√™me arr√™t√©s)
docker ps -a

# 2. Regarder les logs du conteneur
docker logs <container_id>

# 3. Voir pourquoi il s'est arr√™t√©
docker inspect <container_id> | grep -A 10 State
```

### Causes fr√©quentes et solutions

**Cause 1 : Le processus principal se termine**

Un conteneur Docker s'arr√™te quand son processus principal se termine.

```bash
# ‚ùå MAUVAIS : cette commande se termine imm√©diatement
docker run -d ubuntu echo "Hello"

# ‚úÖ BON : processus qui tourne en continu
docker run -d ubuntu sleep infinity
docker run -d nginx  # nginx tourne en continu
```

**Cause 2 : Erreur dans la commande**

```bash
# Voir l'erreur exacte
docker logs <container_id>

# Exemple : erreur de syntaxe dans le script
# Solution : corriger le Dockerfile ou la commande
```

**Cause 3 : Variables d'environnement manquantes**

```bash
# ‚ùå L'app crash car DATABASE_URL manque
docker run -d mon-app

# ‚úÖ Ajouter les variables n√©cessaires
docker run -d -e DATABASE_URL=mysql://... mon-app
```

---

## üö® Probl√®me 2 : "Impossible de se connecter au conteneur"

### Sympt√¥me

```bash
docker run -d -p 8080:80 nginx
# Mais http://localhost:8080 ne r√©pond pas !
```

### Diagnostic √©tape par √©tape

#### 1. V√©rifier que le conteneur tourne

```bash
docker ps
# Le conteneur doit appara√Ætre avec STATUS "Up"
```

#### 2. V√©rifier les ports

```bash
# Voir les ports mapp√©s
docker ps
# ou plus d√©taill√© :
docker port <container_name>

# V√©rifier que le port est bien √©cout√©
docker exec <container_name> netstat -tlnp
```

#### 3. Tester depuis l'int√©rieur du conteneur

```bash
# Se connecter au conteneur
docker exec -it <container_name> bash

# Tester en local
curl localhost:80
# Si √ßa marche, le probl√®me est le mapping de port
```

#### 4. V√©rifier les logs

```bash
docker logs <container_name>
# Y a-t-il des erreurs au d√©marrage ?
```

### Solutions courantes

**Solution 1 : Port d√©j√† utilis√© sur l'h√¥te**

```bash
# V√©rifier les ports utilis√©s
sudo lsof -i :8080
# ou
sudo netstat -tlnp | grep 8080

# Utiliser un autre port
docker run -d -p 8081:80 nginx
```

**Solution 2 : Mauvais mapping de port**

```bash
# ‚ùå MAUVAIS : ports invers√©s
docker run -d -p 80:8080 mon-app  # app √©coute sur 8080

# ‚úÖ BON : format = h√¥te:conteneur
docker run -d -p 8080:8080 mon-app
```

**Solution 3 : Firewall qui bloque**

```bash
# Sur Ubuntu
sudo ufw status
sudo ufw allow 8080

# Red√©marrer Docker peut aider
sudo systemctl restart docker
```

---

## üö® Probl√®me 3 : "docker: Error response from daemon: Conflict"

### Sympt√¥me

```bash
docker run --name mon-app nginx
# Error: container name "mon-app" is already in use
```

### Solutions

```bash
# Voir tous les conteneurs (actifs et arr√™t√©s)
docker ps -a

# Option 1 : Supprimer l'ancien conteneur
docker rm mon-app

# Option 2 : Supprimer m√™me s'il tourne
docker rm -f mon-app

# Option 3 : Utiliser un autre nom
docker run --name mon-app-v2 nginx
```

---

## üö® Probl√®me 4 : "No space left on device"

### Sympt√¥me

```bash
docker build -t mon-image .
# Error: no space left on device
```

### Diagnostic

```bash
# Voir l'espace disque utilis√© par Docker
docker system df

# R√©sultat exemple :
# TYPE            TOTAL     ACTIVE    SIZE
# Images          42        10        15.2GB
# Containers      25        2         1.3GB
# Local Volumes   8         2         2.5GB
# Build Cache     0         0         0B
```

### Solutions

```bash
# 1. Nettoyer les conteneurs arr√™t√©s
docker container prune

# 2. Nettoyer les images non utilis√©es
docker image prune

# 3. Nettoyer les volumes non utilis√©s
docker volume prune

# 4. TOUT NETTOYER (attention !)
docker system prune -a --volumes

# Confirmation requise !
# ATTENTION : supprime TOUT ce qui n'est pas utilis√©
```

---

## üö® Probl√®me 5 : "Mon application est TR√àS lente dans Docker"

### Diagnostic des performances

```bash
# 1. Voir l'utilisation CPU et RAM en temps r√©el
docker stats

# 2. Voir les stats d'un conteneur sp√©cifique
docker stats mon-conteneur

# 3. Inspecter les limites de ressources
docker inspect mon-conteneur | grep -i memory
```

### Solutions d'optimisation

#### Limiter les ressources (√©viter qu'un conteneur monopolise tout)

```bash
# Limiter la RAM
docker run -d --memory="512m" mon-app

# Limiter le CPU (50% d'un core)
docker run -d --cpus="0.5" mon-app

# Combiner les deux
docker run -d \
  --memory="1g" \
  --cpus="2" \
  --name mon-app-optimise \
  mon-app
```

#### Probl√®me de volumes sur Windows/Mac

```bash
# ‚ùå LENT : volumes mont√©s depuis Windows/Mac
docker run -v /chemin/local:/app mon-app

# ‚úÖ RAPIDE : utiliser un volume Docker nomm√©
docker volume create mon-volume
docker run -v mon-volume:/app mon-app
```

---

## üîç Commandes de diagnostic avanc√©es

### Inspecter tout le d√©tail d'un conteneur

```bash
# Toutes les infos en JSON
docker inspect mon-conteneur

# Filtrer une info pr√©cise
docker inspect mon-conteneur --format='{{.State.Status}}'
docker inspect mon-conteneur --format='{{.NetworkSettings.IPAddress}}'
```

### Voir les processus dans un conteneur

```bash
# Liste des processus
docker top mon-conteneur

# Version d√©taill√©e
docker exec mon-conteneur ps aux
```

### Analyser les √©v√©nements Docker

```bash
# Voir tous les √©v√©nements en temps r√©el
docker events

# Filtrer par conteneur
docker events --filter container=mon-conteneur

# Filtrer par type d'√©v√©nement
docker events --filter event=start
```

### D√©bugger le r√©seau

```bash
# Lister les r√©seaux
docker network ls

# Inspecter un r√©seau
docker network inspect bridge

# Voir les conteneurs dans un r√©seau
docker network inspect mon-reseau --format='{{range .Containers}}{{.Name}} {{end}}'
```

---

## üêõ Techniques de debugging avanc√©es

### Technique 1 : Entrer dans un conteneur qui crash

```bash
# Si le conteneur crash au d√©marrage, emp√™cher le crash
docker run -it --entrypoint /bin/bash mon-image

# Maintenant vous √™tes dedans, vous pouvez investiguer !
```

### Technique 2 : Copier des fichiers pour analyser

```bash
# Copier UN fichier depuis le conteneur
docker cp mon-conteneur:/var/log/app.log ./app.log

# Copier un dossier complet
docker cp mon-conteneur:/var/log ./logs
```

### Technique 3 : D√©bugger avec des outils

```bash
# Installer des outils de debug dans le conteneur
docker exec -it mon-conteneur bash
apt-get update
apt-get install -y curl vim net-tools

# Tester depuis l'int√©rieur
curl http://localhost:8080
netstat -tlnp
```

### Technique 4 : Analyser les logs en d√©tail

```bash
# Voir les 100 derni√®res lignes
docker logs --tail 100 mon-conteneur

# Suivre en temps r√©el avec timestamp
docker logs -f --timestamps mon-conteneur

# Filtrer par date
docker logs --since 2024-01-01T10:00:00 mon-conteneur
docker logs --since 1h mon-conteneur  # derni√®re heure
```

---

## üö® Probl√®mes Docker Compose sp√©cifiques

### Probl√®me : "Service xyz is unhealthy"

```bash
# Voir les d√©tails du healthcheck
docker inspect <container_name> | grep -A 20 Health

# Tester manuellement le healthcheck
docker exec mon-conteneur curl http://localhost/health
```

### Probl√®me : "Cannot connect to service"

```bash
# Les conteneurs doivent utiliser le nom du service, pas localhost
# ‚ùå MAUVAIS dans app :
# DATABASE_URL=mysql://localhost:3306

# ‚úÖ BON dans app :
# DATABASE_URL=mysql://db:3306  # "db" = nom du service
```

### Probl√®me : "depends_on not working"

```yaml
# ‚ùå depends_on ne garantit PAS que le service est PR√äT
services:
  app:
    depends_on:
      - db  # D√©marre apr√®s db, mais db peut ne pas √™tre pr√™te

# ‚úÖ Utiliser un healthcheck
services:
  db:
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 5s
      timeout: 3s
      retries: 5
  
  app:
    depends_on:
      db:
        condition: service_healthy  # Attend que db soit healthy !
```

---

## ‚ö° Guide d'optimisation des performances

### 1. Optimiser les images

```dockerfile
# ‚ùå LENT : image lourde
FROM ubuntu
RUN apt-get update && apt-get install -y python3

# ‚úÖ RAPIDE : image l√©g√®re
FROM python:3.11-alpine
```

### 2. Utiliser le cache de build intelligemment

```dockerfile
# ‚ùå INEFFICACE : copie tout avant d'installer
COPY . /app
RUN pip install -r requirements.txt

# ‚úÖ OPTIMIS√â : copie d'abord requirements, installe, puis copie le code
COPY requirements.txt /app/
RUN pip install -r requirements.txt
COPY . /app
# Comme √ßa, si le code change, on ne r√©installe pas les d√©pendances !
```

### 3. Multi-stage builds pour r√©duire la taille

```dockerfile
# Stage 1 : Build
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Stage 2 : Production (image finale plus petite !)
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY package*.json ./
RUN npm install --production
CMD ["node", "dist/index.js"]
```

### 4. Nettoyer dans le Dockerfile

```dockerfile
# ‚ùå Laisse des fichiers temporaires
RUN apt-get update
RUN apt-get install -y python3
RUN apt-get clean

# ‚úÖ Nettoie dans la m√™me couche
RUN apt-get update && \
    apt-get install -y python3 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

---

## üèãÔ∏è Exercice Pratique : Troubleshooting Challenge

### Mission
D√©bugger une application qui ne fonctionne pas !

```bash
# 1. Cr√©er un fichier Dockerfile avec une erreur volontaire
cat > Dockerfile << 'EOF'
FROM python:3.11
WORKDIR /app
COPY . .
CMD ["python", "app.py"]
EOF

# 2. Cr√©er app.py avec une erreur
cat > app.py << 'EOF'
import os
database_url = os.environ['DATABASE_URL']  # Variable manquante !
print(f"Connecting to {database_url}")
EOF

# 3. Build et run
docker build -t debug-exercise .
docker run --name test-debug debug-exercise
```

### Questions √† r√©soudre :
1. Pourquoi le conteneur crash ?
2. Comment voir l'erreur ?
3. Comment la corriger ?

### Solutions :

```bash
# 1. Voir l'erreur
docker logs test-debug
# KeyError: 'DATABASE_URL'

# 2. Corriger en ajoutant la variable
docker run --name test-debug-fixed \
  -e DATABASE_URL=postgresql://localhost/mydb \
  debug-exercise

# √áa marche ! üéâ
```

---

## üìä Checklist de troubleshooting

Quand quelque chose ne marche pas, suivez cette checklist dans l'ordre :

### ‚úÖ Niveau 1 : Les bases
- [ ] Le conteneur tourne-t-il ? (`docker ps`)
- [ ] Y a-t-il des erreurs dans les logs ? (`docker logs`)
- [ ] Les ports sont-ils correctement mapp√©s ? (`docker port`)
- [ ] L'image est-elle √† jour ? (`docker pull`)

### ‚úÖ Niveau 2 : Configuration
- [ ] Les variables d'environnement sont-elles d√©finies ?
- [ ] Les volumes sont-ils mont√©s correctement ?
- [ ] Les permissions des fichiers sont-elles correctes ?
- [ ] Le r√©seau est-il configur√© ? (`docker network inspect`)

### ‚úÖ Niveau 3 : Ressources
- [ ] Y a-t-il assez d'espace disque ? (`docker system df`)
- [ ] Le conteneur a-t-il assez de RAM ? (`docker stats`)
- [ ] Le CPU est-il surcharg√© ?
- [ ] Y a-t-il des conflits de ports ?

### ‚úÖ Niveau 4 : Avanc√©
- [ ] Le healthcheck fonctionne-t-il ?
- [ ] Les d√©pendances entre services sont-elles respect√©es ?
- [ ] Les DNS r√©solvent-ils correctement ?
- [ ] Y a-t-il des probl√®mes de firewall ?

---

## üéØ Quiz de validation

### Question 1
Un conteneur d√©marre puis s'arr√™te imm√©diatement. Quelle est la PREMI√àRE commande √† utiliser ?

**A)** `docker restart`  
**B)** `docker logs`  
**C)** `docker rm`  
**D)** `docker system prune`

<details>
<summary>Voir la r√©ponse</summary>

**R√©ponse : B) `docker logs`**

Les logs vous diront POURQUOI le conteneur s'est arr√™t√©. C'est toujours la premi√®re chose √† v√©rifier !
</details>

### Question 2
Comment lib√©rer de l'espace disque en supprimant TOUT ce qui n'est pas utilis√© ?

**A)** `docker rm -a`  
**B)** `docker prune`  
**C)** `docker system prune -a --volumes`  
**D)** `docker clean --all`

<details>
<summary>Voir la r√©ponse</summary>

**R√©ponse : C) `docker system prune -a --volumes`**

Cette commande supprime :
- Tous les conteneurs arr√™t√©s
- Toutes les images non utilis√©es
- Tous les volumes non utilis√©s
- Tout le cache de build

ATTENTION : utilisez avec pr√©caution !
</details>

### Question 3
Votre application ne peut pas se connecter √† la base de donn√©es. Dans docker-compose, quel est le probl√®me ?

```python
# Dans l'application :
DATABASE_URL = "mysql://localhost:3306/mydb"
```

**A)** Le port est incorrect  
**B)** Le mot de passe manque  
**C)** Il faut utiliser le nom du service, pas "localhost"  
**D)** MySQL n'est pas compatible avec Docker

<details>
<summary>Voir la r√©ponse</summary>

**R√©ponse : C) Il faut utiliser le nom du service**

Dans Docker Compose, les services communiquent via leurs noms de service :
```python
# ‚úÖ BON :
DATABASE_URL = "mysql://db:3306/mydb"  # "db" = nom du service
```
</details>

---

## üìù R√©capitulatif des commandes essentielles

### Diagnostic

```bash
docker ps -a                    # Tous les conteneurs
docker logs <container>         # Voir les logs
docker logs -f <container>      # Suivre les logs
docker inspect <container>      # Toutes les infos
docker stats                    # Stats en temps r√©el
docker top <container>          # Processus
docker system df                # Espace disque
```

### Debugging

```bash
docker exec -it <container> bash    # Entrer dans le conteneur
docker cp <container>:/file ./      # Copier un fichier
docker port <container>             # Voir les ports
docker events                       # √âv√©nements en temps r√©el
```

### Nettoyage

```bash
docker container prune          # Conteneurs arr√™t√©s
docker image prune              # Images non utilis√©es
docker volume prune             # Volumes non utilis√©s
docker system prune -a          # TOUT nettoyer
```

### Performance

```bash
docker run --memory="1g" ...    # Limiter RAM
docker run --cpus="2" ...       # Limiter CPU
docker stats                    # Monitorer
```

---

## üöÄ Points cl√©s √† retenir

1. **Toujours v√©rifier les logs en premier** (`docker logs`)
2. **Un conteneur s'arr√™te si son processus principal se termine**
3. **Format des ports : `-p h√¥te:conteneur`**
4. **Dans docker-compose, utiliser les noms de services, pas localhost**
5. **Nettoyer r√©guli√®rement** (`docker system prune`)
6. **Utiliser `docker stats` pour surveiller les performances**
7. **`docker inspect` donne TOUTES les infos**
8. **Les volumes nomm√©s sont plus rapides que les bind mounts sur Win/Mac**

---

## üéì Prochaines √©tapes

F√©licitations ! Vous savez maintenant :
- ‚úÖ Diagnostiquer n'importe quel probl√®me Docker
- ‚úÖ Utiliser les commandes avanc√©es
- ‚úÖ Optimiser les performances
- ‚úÖ D√©bugger efficacement

Dans le **Cours 12 (Projet Final)**, vous allez :
- Cr√©er une application compl√®te de A √† Z
- G√©rer plusieurs services
- Appliquer toutes les bonnes pratiques
- D√©ployer en production

**Vous √™tes maintenant un expert du troubleshooting Docker !** üéâ

---

## üìö Ressources compl√©mentaires

- [Docker Troubleshooting Guide](https://docs.docker.com/config/daemon/troubleshoot/)
- [Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [Performance Optimization](https://docs.docker.com/config/containers/resource_constraints/)

---

**Pr√™t pour le projet final ?** üí™
